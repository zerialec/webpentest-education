# Ход занятия.
***1.***  Сегодня мы с вами начинаем изучать Linux, как одну из составных частей мира
информационных технологий под названием Unix. Все вы, ну или практически все раньше
сталкивались с ОС семейства Windows. Я хочу сделать небольшое примечание – Unix не
Windows, он не похож на него (не считая внешнего сходства) и приемы работы в unix
отличаются от приемов работы в Windows. Unix – это не только операционная система, это
еще и идеология работы с компьютером. Те правила, о которых мы с вами будем говорить
сейчас лежат в основе изучения Linux, да и Unix вообще. Общий термин для них – Unix
Way:
- одна задача – одна программа. В Unix не принято делать комбайны для выполнения
«сразу всего». Программа делается таким образом, чтобы она могла выполнять одно
простое действие, но выполняла его хорошо.
- есть множество путей решения. Для решений той или иной комплексной задачи
каждый может выбирать свой набор простых компонент для ее решения.
- все есть файл. Самая замечательная концепция в unix. Действительно, в Unix все
представлено в виде файлов – программы, настройки, системные данные и даже
устройства. И с устройствами можно работать как с простыми файлами.
Остальную часть Unix way мы с Вами будем изучать в течение этого курса. Будьте
готовы к изучению не просто новых программ, а новых методов работы на компьютере.

 ***2.*** В 1969 году Кен Томпсон и Денис Ритчи, работники корпорации AT&T, создали
небольшую операционную систему для компьютера PDP7.
Эта операционная система
получила название Unix. Однако в планы компании AT&T не входило распространение
этой операционной системы, и она предоставила ее за символическую плату учебным
заведениям США, не организовав при этом службы технического сопровождения,
исправления ошибок и вообще не дав никаких гарантий.
Вследствие этого пользователи, почти все являвшиеся представителями
университетских вычислительных центров, были вынуждены сотрудничать друг с другом.
Они сами устраняли ошибки, создавали полезные программы и утилиты и совместно их
использовали. Результатом их работы стала целая серия версий Unix, распространяемых
под эгидой компании Bell Labs вплоть до 1990 года (Последней версией была Unix System
V Release 4 – SVR4).
Одна из групп пользователей Unix находилась в калифорнийском университете в
Беркли. В 1977 году специалисты этого учебного заведения сделали следующий шаг в
истории Unix и приступили к распространению магнитных лент с операционной системой
2BSD (Berkeley Software Distribution). С тех пор было продано 75 копий.
На основании Unix SVR4 и BSD были созданы все современные разновидности
Unix.

***3.***  Существует множество разновидностей Unix и Unixподобных
систем. К наиболее
известным из них относятся Solaris (ранее SunOS) корпорации SUN Microsystems, AIX
компании IBM, DEC Unix фирмы DEC, SCO UnixWare и прочие. Все вышеназванные
системы являются коммерческими, и многие из них имеют высокую цену. Они работают на
различных архитектурах (Intel, Sparc, Alpha, PowerPC и т.д.). Однако наибольший интерес
сегодня в мире Unix приобрели операционные системы, построенные на модели открытого
кода, такие как Linux.
Linux изначально была разработана как свободно распространяемая версия Unix. В
1991 году студент Хельсинского университета Линус Торвальдс выпустил первую версию
Linux. Она была основана на операционной системе Minix – ограниченном аналоге Unix для
ПК. После выпуска первого «почти безошибочного» релиза в марте 1992 года, многие
программисты мира подключились к разработке этой операционной системы, и она стала
расти.
На сегодняшний день Linux является полнофункциональным, открытым и зачастую,
бесплатным, аналогом Unix. Но этого бы не произошло, не будь программного обеспечения
в рамках проекта GNU (GNU’s not Unix, GNU – это не Unix). Linux содержит много
утилит GNU, включая трансляторы многих языков программирования (C, C++, Fortran,
Pascal, LISP, Ada, BASIC, SmallTallk, Perl, PHP, Tcl/Tk и др.), отладчики, текстовые
редакторы, утилиты печати и многое другое. Проект GNU развивается под эгидой фонда
свободно распространяемого программного обеспечения – Free Software Foundation (FSF).

***4.***  Linux является свободно распространяемой многозадачной
многопользовательской операционной системой, похожей на Unix. Linux была разработана
специально для платформы ПК (с процессором Intel) и благодаря преимуществам
архитектуры позволяет достичь производительности, сравнимой с мощными рабочими
станциями Unix. Linux также переносилась и на другие платформы, но все эти версии
сходны с версией для ПК.
Давайте рассмотрим операционную систему как единый комплекс. Ниже приведен
список того, что мы получим, установив ее:
# Ядро Linux:
Ядро это
основная часть операционной системы. Оно отвечает за распределение
памяти, управление процессами и периферийными устройствами. Для поддержки большего
объема оперативной памяти по сравнению с физически установленной на компьютере, ядро
позволяет использовать область подкачки, размещая страницы оперативной памяти на
жестком диске.
Ядро Linux поддерживаем множество файловых систем, включая FAT, FAT32.
Собственные файловые системы Linux (ext2fs и ext3fs) разработаны для оптимального
использования дискового пространства.
# Утилиты GNU:
Linux содержит множество утилит GNU, без которых была бы невозможна работа с
операционной системой.
# X Window:
Графический интерфейс пользователя представлен в Linux средой X Window.
Различные оконные менеджеры (IceWM, WindowMaker, Fluxbox и прочие) и графические
среды такие как KDE и GNOME, обеспечивают удобный интерфейс и работу со
средствами мультимедиа.
# Интерфейсы DOS и Windows:
Поскольку Linux была создана для компьютеров класса ПК, разработчики
посчитали необходимым обеспечить совместимость с программами MSDOS.
В Linux
предлагается эмулятор DOS как часть дистрибутива. Он позволяет исполнять DOSприложения
непосредственно изпод
Linux. Для запуска программ Microsoft Windows было
разработано несколько средств. Наиболее известное из них – WINE – свободная реализация
Windows API. Wine также входит в большинство дистрибутивов Linux.
Linux позволяет без проблем переносить файлы между файловыми системами DOS
и Windows, напрямую обращаясь к соответствующим разделам на диске, хотя это и
требует некоторой настройки.
# Сетевая поддержка:
TCP/IP – основная сетевая система используемая Unix и Linux. TCP/IP – это целый
набор протоколов, разработанных для Internet. Однако для объединения в локальные сети
машин Unix тоже используется TCP/IP. Также Linux поддерживает другие протоколы,
такие как IPX/SFX, AppleTalk и т.д.
  ***5.***  Встает вопрос – как же узнать тип операционной системы, установленной у вас на
компьютере. Для получения такой информации существует утилита uname (Unix NAME).
uname, запущенная без параметров, покажет базовое имя системы:
[gserg@admin ~]$ uname
Linux
Также она может принимать следующие параметры:
s
– показывает название ядра системы
r
– имя релиза ядра системы
v
– имя версии, а также дату компиляции ядра
o
– операционную систему
p
– тип процессора
m
– тип оборудования (i386, i686, Alpha)
a
– всю информацию сразу
Это не все параметры uname. О справке Linux мы поговорим с вами на 5м
занятии.
Команда free показывает объем памяти и объем ее использования, а также
использование swap:
gserg@ADM:~$ free
total used free shared buffers cached
Mem: 498916 483332 15584 0 4392 112924
-/+ buffers/cache: 366016 132900
Swap: 1453840 412532 1041308
Обратите внимание, что практически вся свободная память резервируется системой
под дисковые буферы и дисковый кэш, что позволяет Linux более эффективно работать с
дисками.
Состояние системы в данный момент, степень ее загруженности и время без
перезагрузок показывает команда uptime:
gserg@ADM:~$ uptime
14:24:08 up 1 day, 6:01, 2 users, load average: 0.08, 0.19, 0.16
Первым идет текущее время, потом, после слова up – время, прошедшее с момента
включения компьютера, потом показано сколько пользователей зарегистрировано сейчас в
системе (это может быть и несколько регистраций одного и того же пользователя) и
загрузка системы. Загрузка системы показывается в количестве процессов, одновременно
работающих в системе, среднее значение за 1ну,
5 и 15 минут. Система считается
нагруженной, если это значение превышает 1 в расчете на 1 процессор.
Другим средством мониторинга производительности является команда vmstat:
[gserg@admin ~]$ vmstat
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
r b swpd free buff cache si so bi bo in cs us sy id wa st
0 0 268928 776168 15072 203316 1 2 10 14 207 225 13 3 84 0 0
Эта команда выдает за раз достаточно большой объем информации.
Раздел procs:
r — количество ожидающих процессов
b — количество спящих процессов
Раздел memory:
swpd — объем используемой виртуальной памяти
free — объем свободной виртуальной памяти
buff — объем памяти, занятой под дисковые буферы
cache объем
памяти, занятой под дисковый кэш
Раздел swap:
si — объем памяти, подкачанной с диска
so — объем памяти, выгруженной на диск
Раздел io:
bi — количество блоков, отправленных на блочное устройство
bo — количество блоков, прочитанных с блочного устройства
Раздел system:
in — количество прерываний в секунду
cs — количество переключений контекста в секунду
Раздел cpu:
us — время выполнения кода уровня пользователя (в процентах от общего
времени)
sy — время выполнения кода уровня системы (в процентах от общего времени)
id — время простоя процессора (в процентах от общего времени)
wa — время ожидания ввода/вывода
st — время работы виртуальной машины уровня ядра
vmstat показывает при простом запуске усредненные показатели за все время с
момента запуска системы. Но можно попросить vmstat вывести показатели за заданное
количество времени:
[gserg@admin ~]$ vmstat 1 5
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
r b swpd free buff cache si so bi bo in cs us sy id wa st
1 0 268844 742148 16620 212452 1 2 10 14 216 230 13 3 84 0 0
0 0 268844 742140 16628 212436 0 0 0 48 1097 414 6 2 92 0 0
0 0 268844 742140 16628 212436 0 0 0 0 1105 392 5 1 94 0 0
0 0 268844 742172 16628 212436 0 0 0 0 1090 345 4 1 95 0 0
0 0 268844 742172 16628 212436 0 0 0 0 1107 403 6 1 93 0 0
В примере выведена информация за каждую секунду на протяжении 10 секунд. Если
второй параметр (5) не указывать, то vmstat будет выводить информацию каждую секунду
до нажатия Ctrl+C:
[gserg@admin ~]$ vmstat 1
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
r b swpd free buff cache si so bi bo in cs us sy id wa st
0 0 268844 740824 16824 212720 1 2 10 14 217 230 13 3 84 0 0
0 0 268844 740856 16824 212720 0 0 0 0 1088 488 8 2 90 0 0
0 0 268844 740856 16824 212720 0 0 0 0 1392 873 14 4 82 0 0
^C
Для просмотра размеров файловых систем используется команда df:
[gserg@admin ~]$ df
Файловая система 1K-блоков Исп Доступно Исп% смонтирована на
/dev/hdb2 36733400 10074596 24762736 29% /
/dev/hdb1 101086 16228 79639 17% /boot
tmpfs 647688 0 647688 0% /dev/shm
Без параметров команда выводит данные в виде количсетва блоков по 1 килобайту.
Для человека это не очень удобная подача информации. У df существует ключ h
(или —
human), позволяющий увидеть объемы в привычных нам единицах измерения:
[gserg@admin ~]$ df --human
Файловая система Разм Исп Дост Исп% смонтирована на
/dev/hdb2 36G 9,7G 24G 29% /
/dev/hdb1 99M 16M 78M 17% /boot
tmpfs 633M 0 633M 0% /dev/shm
